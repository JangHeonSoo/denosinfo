---
title: 'OpenCode와 Oh-My-OpenCode: CLI 툴의 새로운 지평'
description: '바이브 코딩을 위한 최고의 CLI 툴, OpenCode와 그 강력한 확장판 Oh-My-OpenCode의 모든 것을 파헤칩니다.'
pubDate: 2026-02-02
category: 'development'
tags: ['OpenCode', 'CLI', 'AI', 'CodingAgent', 'Sisyphus', 'OpenSource']
heroImage: '/images/opencode-hero.png'
---

# OpenCode와 Oh-My-OpenCode: CLI 툴의 새로운 지평

바이브 코딩용 **CLI** 툴 1등. 내 주관적 생각.

사실 터미널에서 **AI** 코딩한다는 게 처음엔 좀 이상하게 들릴 수 있다. **IDE** 놔두고 왜 검은 화면으로 돌아가냐고. 그런데 막상 써보면 안다. 손이 키보드에서 떨어지지 않는 그 쾌감을.

**OpenCode**는 오픈소스 **AI** 코딩 에이전트다. 터미널 기반이고, 무료고, 월 65만명이 쓴다. 그냥 `opencode` 치면 **TUI** (Terminal User Interface)가 뜬다. 여기서부터 모든 게 시작된다.

![Terminal TUI Interface](/images/terminal-tui.png)

## 왜 굳이 OpenCode인가

**Claude Code**도 있고 **Cursor**도 있다. 근데 **OpenCode**는 다르다. 일단 **75개 이상의 LLM을 자유롭게 갈아 끼운다**. **Claude** 쓰다가 **GPT**로, **Gemini**로, 심지어 로컬 **Ollama** 모델까지. 벤더에 종속되지 않는다는 건 생각보다 큰 자유다.

**LSP** (Language Server Protocol)가 자동으로 로드된다. **TypeScript** 프로젝트 열면 **TypeScript** 서버가 알아서 붙고, **Python**이면 **Pyright**가 붙는다. 30개 이상 언어를 지원한다. 정의 이동, 참조 찾기, 타입 정보. **IDE**가 주는 그 편안함이 터미널에 그대로 있다.

멀티 세션도 지원한다. 같은 프로젝트에서 여러 에이전트를 동시에 돌릴 수 있다. **Build** 에이전트로 코드 짜면서 **Plan** 에이전트로 다음 단계 설계하는 식이다. 병렬 작업이 가능하다는 얘기다.

### Build와 Plan, 두 얼굴

**OpenCode**는 기본으로 두 에이전트를 준다. **Build**와 **Plan**.

**Build**는 풀 액세스다. 파일 읽고, 쓰고, 수정하고, 쉘 커맨드까지 실행한다. 실제 작업을 하는 놈이다. 반면 **Plan**은 읽기 전용이다. 코드베이스 분석하고, 아키텍처 제안하고, 계획 세우는 역할. 손대지 않고 머리만 쓴다.

**Tab** 키 하나로 둘을 오간다. **Plan**으로 전략 짜고, **Build**로 구현하고. 이게 **OpenCode**가 제시하는 기본 워크플로우다.

## Oh-My-OpenCode는 뭐가 다른가

여기서 **Oh-My-OpenCode**가 등장한다. **OpenCode** 위에서 돌아가는 플러그인이다. 그런데 단순 플러그인 수준이 아니다. **"혼자 일하는 AI"를 "팀으로 협업하는 AI"로 바꾼다**.

개발자 **code-yeongyu**가 $24,000 상당의 토큰을 쏟아부어 테스트했다. 이건 그냥 취미 프로젝트가 아니라는 얘기다.

### Sisyphus, 끝까지 가는 놈

**Oh-My-OpenCode**의 심장은 **Sisyphus**다. 그리스 신화의 시시포스처럼 끝까지 포기하지 않는다. 메인 오케스트레이터 역할이다.

![Sisyphus Orchestrator](/images/sisyphus-agent.png)

작업이 들어오면 **Sisyphus**가 분해한다. 어떤 건 **Oracle**에게, 어떤 건 **Librarian**에게, 어떤 건 직접 처리한다. 각 에이전트는 자기 영역에만 집중한다. 백그라운드에서 병렬로 돌아간다.

**Todo Continuation Enforcer**라는 게 있다. **AI**가 긴 작업 도중 멈추는 걸 방지한다. 할 일 목록이 남아있으면 강제로 계속 진행시킨다. 끝까지 완주하게 만드는 장치다.

**Comment Checker**도 재밌다. **AI**가 코드에 주석을 과하게 다는 버릇이 있다. `// This function adds two numbers` 같은 쓸데없는 주석 말이다. **Comment Checker**가 이걸 걸러낸다. 인간이 쓴 것처럼 깔끔하게 유지한다.

### 전문가 팀 구성

**Oh-My-OpenCode**는 7개 이상의 전문 에이전트를 돌린다.

![AI Agent Team Collaboration](/images/agent-team.png)

- **Oracle**: 아키텍처 설계, 디버깅 전략. **Opus 4.5** 같은 고급 모델을 쓴다.
- **Librarian**: 멀티 레포지토리 분석. 문서 찾고, **GitHub** 검색하고, 구현 예시 가져온다. **GLM-4.7 Free** 모델로 돌린다.
- **Navigator**: 코드베이스 탐색. 파일 구조 파악하고 의존성 추적한다.
- **Implement**: 실제 코드 작성. 패턴 따르고, 컨벤션 유지한다.
- **Document-writer**: 기술 문서 작성. **README**부터 **API** 문서까지.
- **Multimodal-looker**: **PDF**, 이미지, 다이어그램 분석. 시각 자료에서 정보 추출한다.

각자 잘하는 걸 한다. 탐색할 땐 빠른 모델, 설계할 땐 똑똑한 모델, 구현할 땐 중간 모델. 비용 최적화가 자동으로 된다.

## 설치는 어떻게 하나

### OpenCode 깔기

제일 간단한 방법:

```bash
curl -fsSL https://opencode.ai/install | bash
```

패키지 매니저로도 된다:

```bash
# macOS
brew install anomalyco/tap/opencode

# Windows
scoop bucket add extras
scoop install extras/opencode

# Arch Linux
paru -S opencode-bin
```

버전 확인:

```bash
opencode --version  # 1.0.150 이상이어야 함
```

### Oh-My-OpenCode 얹기

**Bun**이 필요하다:

```bash
# macOS/Linux
curl -fsSL https://bun.sh/install | bash

# Windows
powershell -c "irm bun.sh/install.ps1|iex"
```

그 다음:

```bash
bunx oh-my-opencode install
```

설치 마법사가 뜬다. 질문 세 개:

1. **Claude Pro/Max** 쓰냐?
2. **ChatGPT Plus/Pro** 쓰냐?
3. **Google Gemini** 쓰냐?

솔직하게 답하면 된다. 자동으로 설정 파일 두 개가 생긴다:
- `~/.config/opencode/opencode.json`
- `~/.config/opencode/oh-my-opencode.json`

### 인증하기

각 제공자마다 로그인 필요하다:

```bash
# Claude
opencode auth login
# → Anthropic 선택 → OAuth 인증

# ChatGPT
opencode auth login
# → OpenAI 선택 → 브라우저 열림

# Gemini
opencode auth login
# → Google 선택 → Antigravity OAuth

# 확인
opencode auth list
```

## 실제로 어떻게 쓰나

### 기본 워크플로우

프로젝트 폴더에서:

```bash
opencode
```

**TUI**가 뜬다. 파일 참조는 `@`로:

```
@src/api.ts에서 인증은 어떻게 처리하나?
```

쉘 명령은 `!`로:

```
!git log --oneline -10
```

슬래시 명령어도 있다:

- `/init` - **AGENTS.md** 파일 생성. 프로젝트 컨텍스트와 규칙 정의한다.
- `/models` - 모델 목록 보기. 여기서 **LLM** 바꾼다.
- `/compact` - 세션 압축. 토큰 아낄 때.
- `/undo` - 방금 한 거 취소. **Git**으로 관리된다.
- `/sessions` - 다른 세션으로 전환.

**Tab** 키로 에이전트 전환한다. **Build** ↔ **Plan**. 손 안 떼고 계속 타이핑할 수 있다.

### Oh-My-OpenCode 활용법

일반 모드로 시작하면 **Sisyphus**가 알아서 판단한다. 어떤 에이전트를 쓸지, 순서는 어떻게 할지. 근데 직접 지정할 수도 있다:

```
@oracle 이 부분 아키텍처 제안 부탁해
```

`@`로 에이전트를 직접 멘션한다. 명시적으로 특정 전문가에게 요청하는 방식이다.

**ultrawork** 키워드도 있다. 완전 자동 모드다. 이걸 쓰면:

- 병렬 에이전트 실행
- 백그라운드 작업 활성화
- **Todo Continuation Enforcer** 작동
- 전문 에이전트 자동 위임
- 완료까지 끝까지 실행

"그냥 해"라고 말하는 거랑 비슷하다. 에이전트가 탐색하고, 계획 세우고, 구현하고, 검증한다. 개발자는 결과만 확인하면 된다.

## LSP와 도구들

**OpenCode**는 20개 이상의 내장 도구를 제공한다:

- **bash**: 쉘 커맨드 실행. `npm install`, `git status` 뭐든지.
- **edit**: 정확한 문자열 대체로 파일 수정. 주요 편집 방식이다.
- **write**: 새 파일 생성하거나 덮어쓰기.
- **read**: 파일 내용 읽기. 특정 라인 범위 지정 가능.
- **grep**: 정규표현식으로 내용 검색. 빠르다.
- **lsp**: 코드 인텔리전스. 정의, 참조, 호버, 심볼 검색.
- **webfetch**: 웹에서 문서 찾아오기.

**Oh-My-OpenCode**는 여기에 **AST-Grep**을 더한다. 추상 구문 트리 기반 검색이다. 단순 텍스트 매칭이 아니라 코드 구조를 이해한다. 리팩터링할 때 특히 강력하다.

**LSP**는 30개 이상 언어를 자동 지원한다. 파일 열면 알아서 해당 언어 서버가 붙는다. 진단, 타입 정보, 호출 계층까지. **IDE** 수준이다.

## 비용 문제

**AI** 코딩 도구 쓰면 돈이 나간다. **Claude Sonnet**은 1M 토큰당 $3-15다. 하루 3시간 쓰면 월 $50-150. **Oh-My-OpenCode**처럼 병렬 에이전트 돌리면 $200 넘어간다.

여기서 **OpenCode**의 벤더 자유도가 빛난다. 각 에이전트마다 다른 모델 할당이 가능하다:

- **Sisyphus** (오케스트레이터): 저렴한 **DeepSeek** ($0.27/M 토큰)
- **Oracle** (아키텍처): 추론 모델 **deepseek-reasoner**
- **Librarian** (검색): **GLM-4.7 Free** (무료)
- **Implement** (구현): **Claude Sonnet** 또는 **MiniMax M2.1** ($0.30/M)

작업 유형별로 차등 배치한다. 탐색은 싸게, 설계는 비싸게. 실전에선 이런 하이브리드 전략이 효율적이다.

**MiniMax M2.1**은 특히 재밌다. **Multi-SWE-Bench** 49.4%로 **Claude 3.5 Sonnet**, **Gemini 1.5 Pro**를 넘어섰다. 근데 가격은 **Claude**의 8% 수준이다. 10B 활성화 파라미터로 비용 효율이 극대화되어 있다.

## 설정 파일 뜯어보기

**Oh-My-OpenCode**는 `oh-my-opencode.json`으로 세밀하게 조정한다:

```json
{
  "agents": {
    "sisyphus": {
      "model": "anthropic/claude-opus-4.5",
      "fallback": ["openai/gpt-5", "google/gemini-3-pro"]
    },
    "oracle": {
      "model": "anthropic/claude-opus-4.5"
    },
    "librarian": {
      "model": "zai-coding-plan/glm-4.7"
    }
  },
  "categories": {
    "quick": { "model": "opencode/gpt-5-nano" },
    "unspecified-low": { "model": "zai-coding-plan/glm-4.7" }
  },
  "experimental": {
    "aggressive_truncation": true
  }
}
```

**Fallback chain**이 있다. 첫 모델이 안 되면 자동으로 다음 걸로 넘어간다. 가용성 보장된다.

Categories는 작업 유형별 모델이다. `quick`는 빠른 작업용 나노 모델, `unspecified-low`는 단순 작업용 무료 모델. 명시하지 않은 건 자동으로 최적화된다.

## AGENTS.md, 프로젝트의 기억

`/init` 명령으로 **AGENTS.md**를 만든다. 프로젝트별 컨텍스트와 규칙을 정의하는 파일이다. **Git**에 커밋해서 팀 전체가 공유한다.

**AGENTS.md**는 3단계 계층이다:

1. **Global** (`~/.config/opencode/agents.md`): 개인 코딩 스타일. 모든 프로젝트에 적용.
2. **Project** (프로젝트 루트): 기술 스택, 아키텍처, 프로젝트 컨벤션.
3. **Folder** (하위 디렉터리): 컴포넌트, 유틸리티별 특화 규칙.

**Codex** (또는 **OpenCode**)는 세 파일을 모두 읽고 병합한다. 하위 레벨이 상위 레벨을 오버라이드한다. **Folder** > **Project** > **Global** 순서다.

한번 설정해두면 반복 설명이 필요 없다. 에이전트가 프로젝트 맥락을 기억한다. 이게 생각보다 큰 시간 절약이다.

## 언제 OpenCode고 언제 Oh-My-OpenCode냐

**OpenCode 쓸 때**:

- 개인 프로젝트나 소규모 팀
- 단순 버그 수정, 기능 추가
- 빠른 프로토타이핑
- 비용 최소화가 목표
- 리소스 제한된 환경

**Oh-My-OpenCode 쓸 때**:

- 마이크로서비스 같은 복잡한 아키텍처
- 다양한 기술 스택 혼재
- 설계/구현/디버깅 동시 진행
- 대규모 팀 협업
- 프로젝트 전체 자율 완수 필요

**OpenCode**는 가볍고 빠르다. **Oh-My-OpenCode**는 무겁지만 강력하다. 상황에 맞게 고른다.

## MCP, 외부 세계와 연결

**MCP** (Model Context Protocol)는 **OpenCode**를 외부 서비스와 연결한다. **GitHub**, **Slack**, **Google Drive**, **Sentry** 등. **MCP** 서버를 추가하면 에이전트가 해당 서비스 데이터를 직접 조회한다.

```json
{
  "mcp": {
    "github": {
      "type": "remote",
      "url": "https://mcp.github.com",
      "enabled": true
    },
    "sentry": {
      "type": "remote",
      "url": "https://mcp.sentry.io",
      "enabled": true
    }
  }
}
```

OAuth 인증은 자동이다. 401 응답 감지하면 **OpenCode**가 브라우저 띄워서 인증 진행한다. **Dynamic Client Registration** (RFC 7591) 지원한다.

**Oh-My-OpenCode**는 이걸 적극 활용한다. **grep_app MCP**로 **GitHub** 전체 검색해서 예제 코드 찾아온다. **Librarian** 에이전트가 이걸 쓴다.

근데 **MCP**는 컨텍스트를 많이 잡아먹는다. **GitHub MCP** 같은 건 토큰을 엄청 소모한다. 필요한 것만 켜야 한다. 전역으로 끄고 에이전트별로 선택적으로 켜는 게 좋다.

## 커스텀 명령어와 스킬

**Commands**는 반복 작업을 자동화한다. `/commit`, `/test`, `/review` 같은 거 만들 수 있다. **Markdown** 파일로 정의한다:

```markdown
---
description: Run tests and generate coverage report
---

!npm test
!npm run coverage

Analyze the test results above and suggest improvements.
```

`.opencode/commands/test.md`에 저장하면 `/test`로 실행된다.

**Skills**는 **SOP** (Standard Operating Procedure) 같은 거다. 에이전트가 필요할 때 로드하는 참조 문서. 명령어와 달리 사용자가 직접 호출하지 않는다. 에이전트가 판단해서 쓴다.

차이점:

- **Commands**: 사용자가 명시적으로 호출. 자동완성 지원. 파라미터 전달 가능.
- **Skills**: 에이전트가 필요시 자동 로드. 조합 가능. 컨텍스트에만 추가되고 실행 안 됨.

실전에선 **Skills**에 로직 넣고, **Commands**에서 `use xyz skill. $ARGUMENTS` 식으로 참조하는 패턴이 많다.

## 권한 관리

기본적으로 모든 툴이 허용된다. 근데 `.env` 파일은 기본 거부다. 보안 때문이다.

**Permission** 값은 세 개:

- `allow`: 승인 없이 실행
- `ask`: 사용자 승인 필요
- `deny`: 실행 차단

글롭 패턴 지원한다:

```json
{
  "permission": {
    "bash": {
      "*": "ask",
      "git *": "allow",
      "rm *": "deny"
    }
  }
}
```

마지막 매칭 규칙이 이긴다. `rm -rf /` 같은 위험한 명령은 명시적으로 거부한다.

에이전트별 권한도 설정 가능하다. **Build**는 전부 허용, **Plan**은 읽기만 허용. 이런 식으로 분리한다.

## 세션 관리와 공유

**OpenCode**는 세션을 유지한다. 컨텍스트가 계속 쌓인다. 이전 대화 기억한다.

```bash
# 이전 세션 계속
opencode --continue
opencode -c

# 특정 세션
opencode --session abc123
opencode -s abc123

# 새 세션
/new
```

`/compact`로 세션 압축한다. 긴 대화 내역을 요약으로 바꾼다. 새 세션으로 전환되면서 토큰 절약된다.

`/share`로 세션 공유도 된다. 링크 생성해서 팀원에게 보낸다. 같은 컨텍스트를 볼 수 있다.

## 실전 팁

### Undo 스택 활용

`/undo`는 스택 구조다. 여러 번 취소 가능하다. `/redo`로 복구도 된다. **Git** 기반이라 정확하다. 프로젝트가 **Git** 레포여야 한다.

막 실험하다가 망치면 그냥 `/undo` 여러 번 치면 된다. 마음 편하게 시도할 수 있다.

### Plan 먼저, Build 나중에

**Plan** 에이전트로 전략부터 짠다. 구현 방향 확인하고, **Build**로 넘어간다. 이게 **OpenCode**의 의도된 워크플로우다.

막바로 **Build**로 뛰어들면 방향 잃기 쉽다. **Plan**으로 로드맵 그리고 시작하는 게 안전하다.

### 파일 참조 적극 활용

`@` 문법을 쓴다. 파일명 일부만 쳐도 퍼지 검색으로 찾아준다. 여러 파일 동시 참조 가능하다.

```
@api.ts @auth.ts를 참고해서 새 엔드포인트 추가해줘
```

컨텍스트가 정확해진다. 에이전트가 헤매지 않는다.

### 외부 에디터 연동

`EDITOR` 환경변수 설정하면 `/editor`로 본인 에디터 열린다:

```bash
export EDITOR="code --wait"  # VS Code
export EDITOR="vim"           # Vim
```

긴 프롬프트 쓸 때 유용하다. 터미널 입력창보다 편하다.

## 한계와 트레이드오프

완벽한 도구는 없다. **OpenCode**도 마찬가지다.

컨텍스트 윈도우가 제한적이다. 아무리 세션 관리 잘해도 결국 토큰 제한에 걸린다. **Compact** 자주 써야 하고, 큰 프로젝트에선 부담이다.

**Oh-My-OpenCode**는 설정이 복잡하다. 에이전트 7개 각각 모델 지정하고, **fallback** 체인 설정하고, 카테고리 나누고. 처음 접하면 압도된다. 러닝 커브가 있다.

토큰 소비가 많다. 병렬 에이전트 돌리면 금방 쌓인다. 비용 관리 안 하면 청구서에 깜짝 놀란다. **Sisyphus**가 주석까지 과하게 달면 더 심하다. **Comment Checker**가 있긴 한데 완벽하진 않다.

에이전트 간 조율이 항상 매끄럽진 않다. 가끔 작업이 중복되거나 충돌한다. 한 에이전트가 고친 걸 다른 에이전트가 되돌리는 일도 있다. **Sisyphus**의 판단력에 의존하는데, 항상 최선은 아니다.

로컬 환경 설정이 번거롭다. **OpenCode** 깔고, **Bun** 깔고, 인증하고, 설정 파일 만지고. **Claude Code** 웹 버전처럼 "그냥 되는" 게 아니다. 터미널 익숙해야 하고, **JSON** 건드리는 게 부담스러우면 진입장벽이다.

그래도 쓸 만한 이유가 있다. 벤더 자유도, **LSP** 통합, 멀티 세션, 오픈소스. 이걸 다 합치면 충분히 가치 있다.

## 마치며

**OpenCode**는 터미널 네이티브 **AI** 코딩 에이전트다. 오픈소스고, 벤더 종속 없고, **LSP** 지원하고, 멀티 세션 돌린다. **Build**와 **Plan** 두 에이전트로 기본 워크플로우를 제공한다.

**Oh-My-OpenCode**는 여기에 팀 협업 개념을 더한다. **Sisyphus**가 지휘하고, 7개 전문 에이전트가 병렬로 작업한다. **LSP**와 **AST-Grep**으로 코드를 구조적으로 이해하고, **Todo Enforcer**로 끝까지 완주한다. **Claude Code** 호환 레이어로 기존 워크플로우도 유지된다.

비용 최적화는 작업별 모델 할당으로 해결한다. 탐색은 저렴한 **DeepSeek**, 설계는 **Claude Opus**, 검색은 무료 **GLM-4.7**. 하이브리드 전략이 실전에서 효율적이다.

설정은 복잡하지만 한번 세팅하면 편하다. **AGENTS.md**로 프로젝트 컨텍스트 공유하고, **MCP**로 외부 서비스 연결하고, 커스텀 명령어로 반복 작업 자동화한다.

바이브 코딩용 **CLI** 툴 1등. 내 주관적 생각. 근데 데이터가 뒷받침한다. 월 65만명이 쓰고, $24,000 토큰 테스트했고, 75개 **LLM** 지원한다. 숫자는 거짓말하지 않는다.

손이 키보드에서 떨어지지 않는 그 쾌감. 한번 느껴보면 안다.

---

#OpenCode #OhMyOpenCode #CLI #AI #CodingAgent #Sisyphus #OpenSource #Development #Tech
