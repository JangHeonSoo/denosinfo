---
title: 'Windows에서 CLI를 쓴다고? PowerShell vs Unix Terminal 개발자 관점 비교'
description: '현대적인 개발 환경에서의 Windows PowerShell과 Unix 기반 터미널의 철학, 성능, 그리고 실전 활용도 비교'
pubDate: 2026-01-30
category: 'Tech'
tags: ['Windows', 'Unix', 'CLI', 'PowerShell', 'Terminal', 'WSL2', 'DevTools']
heroImage: '/images/cli-coding-strings.png'
---

# Windows에서 CLI를 쓴다고? PowerShell vs Unix Terminal 개발자 관점 비교

## 시작하며

npm install 하면 되겠지 싶었는데, permission error가 뜨더라. sudo 붙이면 된다고 하는데... 아 맞다. 여긴 Windows다.

요즘 Cursor, OpenCode 같은 AI 코딩 도구 쓰면서 자연스럽게 CLI 중심 개발로 넘어갔다. 예전엔 Eclipse, IntelliJ IDEA, VS Code 같은 IDE를 켜놓고 마우스로 클릭클릭하며 개발했는데, 지금은 전혀 아니다. 터미널 창 하나면 충분하다.

맥북 쓰면서 느낀건데, 개발자 입장에서 macOS는 정말 할 수 있는 게 많다. 그걸 가능하게 하는 게 Terminal. 즉 CLI다. `brew install`, `git clone`, `npm run`... 모든 게 터미널에서 이루어진다.

물론 Windows도 있지. PowerShell...

그런데 과연. Unix 기반의 터미널과 대등하게 쓸 수 있을까? 궁금해서 알아봤다.

## 역사적 배경부터 좀 다르다

### Unix/Linux는 CLI가 근본이다

Unix 계열 OS는 애초에 CLI 중심으로 설계됐다. 1970년대부터 쌓인 노하우가 있다. Bash는 1989년에 나왔고, 수십 년간 검증된 도구들이 기본으로 탑재되어 있다. `grep`, `awk`, `sed`, `find`... 이런 녀석들은 Unix의 DNA다.

macOS도 마찬가지다. NeXTSTEP과 OPENSTEP을 거쳐 Unix 기반으로 만들어졌기 때문에, 강력한 Unix 쉘들을 기본 제공한다. Terminal.app 하나로 zsh, bash, ksh, tcsh 다 돌릴 수 있다. 

### Windows는 나중에 붙인 거다

반면 Windows는 GUI가 먼저였다. DOS 시절엔 CLI가 있었지만, Windows가 나오면서 GUI 중심으로 갔다. CMD(Command Prompt)는... 솔직히 쓰레기였다. 배치 파일 만들어본 사람은 안다. 저 고문 같은 문법.

그래서 Microsoft가 2006년에 PowerShell을 만들었다. "우리도 현대적인 쉘 만들자!" 하면서. 그런데 접근 방식이 완전히 달랐다. 텍스트 파이프가 아니라 객체 파이프. .NET Framework 기반.

문제는 두 개의 쉘을 동시에 유지해야 했다는 점이다. CMD는 하위 호환성 때문에 계속 남아있고, PowerShell은 새로운 자동화 도구로 밀고... 이게 Windows의 "dual-shell strategy"다.

## 철학부터 다르다

### Unix: Everything is a file, everything is text

Unix 철학은 간단하다:

1. 작은 도구를 만들어라
2. 텍스트 스트림으로 연결해라
3. 파이프로 조합해라

예를 들어보자. 로그 파일에서 에러 찾고, 개수 세고, 정렬하는 작업:

```bash
cat app.log | grep "ERROR" | wc -l | sort
```

각 명령어는 텍스트 받고 텍스트 뱉는다. 심플하다. 이게 50년간 검증된 방식이다.

### PowerShell: Everything is an object

PowerShell은 다르다. 객체를 다룬다:

```powershell
Get-Process | Where-Object {$_.CPU -gt 50} | Select-Object Name, CPU
```

여기서 `Get-Process`는 문자열 반환하는 게 아니라 **Process 객체**를 반환한다. 속성(Name, CPU)도 있고, 메서드도 있다. `.NET`의 힘이다.

장점? 텍스트 파싱 안 해도 된다. `awk`나 `sed` 같은 거 몰라도 된다. 객체의 프로퍼티 그냥 접근하면 끝.

단점? 무겁다. Bash보다 느리다. 메모리도 더 먹는다.

## 실제로 써보면 체감되는 차이들

### 1. 패키지 관리자

**macOS: Homebrew**

맥에서 개발 도구 설치는 정말 쉽다:

```bash
brew install git node python
brew install --cask docker visual-studio-code
```

끝이다. Homebrew는 2009년부터 있었고, 생태계가 거대하다. `brew tap`으로 써드파티 저장소도 추가 가능. 폰트도 설치된다:

```bash
brew tap homebrew/cask-fonts
brew install --cask font-fira-code
```

**Windows: Chocolatey? Scoop? Winget?**

Windows는... 복잡하다. 세 개가 경쟁 중이다.

**Chocolatey**:
- 가장 오래됐다 (2011년부터)
- 큰 패키지 저장소
- 근데 관리자 권한 필요
- PowerShell 스크립트 실행 (보안 이슈 가능)

```powershell
choco install git nodejs python
```

**Scoop**:
- 개발자 친화적
- 관리자 권한 불필요! (기본적으로 `~/scoop/`에 설치)
- Unix 스타일 도구들 많음
- PATH 오염 안 시킴 (shim 사용)

```powershell
scoop install git nodejs python
```

**Winget**:
- Microsoft 공식
- Windows 10 1809부터 기본 탑재
- 근데 패키지 개수가...

삽질했던 경험: Scoop으로 개발 도구 깔았는데 OBS Studio 플러그인이 경로를 못 찾더라. 기본 설치 경로(`C:\Program Files`)가 아니라서. 결국 Chocolatey로 다시 깔았다.

나중에 알게 된 것: Scoop은 "portable" 앱들에 최적화되어 있다. CLI 도거나 개발 도구는 Scoop, GUI 애플리케이션은 Chocolatey가 낫다.

### 2. 명령어 스타일

**Unix: 짧고 암호 같다**

```bash
ls -la | grep "config" | awk '{print $9}'
```

처음 보면 뭔 소린지 모른다. 근데 익숙해지면 빠르다. `ls`, `cd`, `mv`, `cp`... 타이핑 적게 하려고 만든 명령어들.

**PowerShell: 동사-명사 구조**

```powershell
Get-ChildItem | Where-Object {$_.Name -like "*config*"} | Select-Object Name
```

길다. 근데 읽기 쉽다. `Get-Process`, `Start-Service`, `New-Item`... 패턴이 있다. IntelliSense도 잘 된다.

근데 PowerShell도 Unix 명령어 alias 지원한다:

```powershell
ls  # Get-ChildItem의 alias
cd  # Set-Location의 alias
cp  # Copy-Item의 alias
```

### 3. 스크립팅

**Bash: 텍스트 처리의 神**

로그 파일에서 IP 주소 추출해서 중복 제거하고 카운트:

```bash
grep -oE '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b' access.log | sort | uniq -c | sort -nr
```

한 줄로 끝난다. `grep`, `awk`, `sed`의 조합은 정말 강력하다.

근데 복잡한 로직은... if문 들여쓰기가 지옥이다:

```bash
if [ -f "$file" ]; then
    if [ -r "$file" ]; then
        echo "파일 읽을 수 있음"
    fi
fi
```

**PowerShell: 프로그래밍 언어에 가깝다**

```powershell
if (Test-Path $file) {
    if (Test-Path $file -PathType Leaf) {
        Write-Host "파일 읽을 수 있음"
    }
}
```

문법이 더 직관적이다. C#이나 JavaScript 써본 사람한테 친숙하다. 에러 핸들링도 try-catch 쓸 수 있다.

25줄짜리 Bash 스크립트가 PowerShell로는 3줄이 될 수도 있다. 객체 덕분에.

### 4. WSL2의 등장

"이게 왜 안되지?" 했던 적 많았다. Windows에서 `make` 돌리려니 안 되고, `rsync` 없고, Bash 스크립트 돌리면 에러 나고.

그래서 나온 게 WSL2(Windows Subsystem for Linux 2)다.

**WSL2의 실체**

WSL1은 Linux 시스템 콜을 Windows API로 변환했다. 에뮬레이션 레이어였다. 느렸고, 호환성도 별로였다.

WSL2는 다르다:
- **진짜 Linux 커널** 돌린다
- Hyper-V 기반 경량 가상화
- Windows 파일 시스템 접근 가능 (`/mnt/c/`)
- VS Code Remote 확장으로 완벽 통합

설치도 간단하다:

```powershell
wsl --install
wsl --set-default-version 2
wsl --install -d Ubuntu-20.04
```

**실전 사용 후기**

Docker가 WSL2에서 훨씬 빠르다. Native Linux만큼은 아니지만, 체감상 큰 차이 없다.

Node.js 개발도 WSL2에서 한다. `npm install`이 Windows보다 빠르고, symbolic link도 문제없다.

근데 네트워킹은 복잡하다. localhost가 WSL 내부와 Windows 사이에서 다르게 동작할 때가 있다.

삽질했던 경험: WSL2에서 git 저장소 작업하다가 Windows에서 열면 모든 파일이 modified로 뜨더라. Line ending 차이 때문이었다. `.gitattributes` 설정으로 해결.

나중에 알게 된 것: WSL2 파일 시스템과 Windows 파일 시스템을 섞어 쓰면 I/O 성능이 떨어진다. WSL 내부에서 작업하고, Windows에서는 보기만 하는 게 낫다.

### 5. 터미널 앱 자체도 다르다

**macOS: Terminal.app + iTerm2**

기본 Terminal.app도 나쁘지 않다. 근데 iTerm2는 차원이 다르다:

- Split panes (수평/수직 분할)
- Hotkey window (단축키로 즉시 띄우기)
- Instant replay (터미널 히스토리 되감기)
- Triggers (특정 텍스트 패턴에 반응)
- 무제한 스크롤백

zsh + oh-my-zsh 조합은 정말 강력하다:

```bash
# .zshrc 설정
ZSH_THEME="agnoster"
plugins=(git zsh-syntax-highlighting zsh-autosuggestions)
```

자동완성이 엄청나다. Git 브랜치 한눈에 보이고, 명령어 제안도 해준다.

**Windows: Windows Terminal**

Microsoft가 2019년에 만든 현대적 터미널:

- 탭, 분할 창 지원
- GPU 가속 텍스트 렌더링
- PowerShell, CMD, WSL 모두 지원
- Quake mode (화면 상단에 고정)
- Command Palette (Ctrl+Shift+P)

설정은 JSON 파일 수정:

```json
{
    "profiles": {
        "defaults": {
            "font": {
                "face": "Cascadia Code",
                "size": 11
            },
            "colorScheme": "One Half Dark"
        }
    }
}
```

Scratchpad 기능도 있다. 긴 명령어 미리 작성해서 붙여넣기 가능.

근데 iTerm2의 Instant Replay 같은 독특한 기능은 없다.

### 6. PATH 환경변수 관리

**Unix: 간단하다**

`~/.zshrc`나 `~/.bashrc`에 한 줄 추가:

```bash
export PATH="$HOME/bin:$PATH"
```

콜론(`:`)으로 구분. 현재 디렉터리(`.`)는 기본적으로 PATH에 없다. 보안상 이유.

**Windows: GUI 지옥**

제어판 → 시스템 → 고급 시스템 설정 → 환경 변수... 클릭 클릭 클릭.

세미콜론(`;`)으로 구분. 현재 디렉터리는 자동으로 검색된다.

PowerShell에서도 가능하긴 하다:

```powershell
$env:PATH += ";C:\MyTools"
```

근데 이건 세션 동안만 유지된다. 영구적으로 하려면 레지스트리 수정해야 한다.

### 7. Symbolic Link (심볼릭 링크)

**Unix: 그냥 된다**

```bash
ln -s /path/to/target /path/to/link
```

끝. 권한 필요 없다.

**Windows: 권한 전쟁**

기본적으로 관리자 권한 필요하다. 보안 때문이라는데...

해결책:
1. 개발자 모드 켜기
2. Local Security Policy에서 사용자에게 권한 주기
3. 관리자 권한으로 실행 (비추천)

```powershell
# 관리자 PowerShell
New-Item -ItemType SymbolicLink -Path "C:\link" -Target "C:\target"
```

Node.js 프로젝트에서 `npm link` 쓰다가 권한 에러 나서 삽질했다. 개발자 모드 켜니까 해결됐다.

나중에 알게 된 것: WSL2 안에서는 symlink가 문제없다. Windows 파일 시스템에 만들 때만 권한 필요.

## 개발 워크플로우 비교

### macOS/Linux: 터미널 하나면 충분

전형적인 개발 워크플로우:

1. iTerm2 실행 (Cmd+Space → "iTerm")
2. tmux 세션 열기:
   ```bash
   tmux new -s myproject
   ```
3. 분할 창 만들기 (Ctrl+b %)
4. Vim으로 코드 편집
5. 테스트 돌리기
   ```bash
   npm test
   ```
6. Git 커밋
   ```bash
   git add . && git commit -m "fix: bug" && git push
   ```

모든 게 키보드로 가능하다. 마우스 안 쓴다. 빠르다.

### Windows: 선택지가 많다

**옵션 1: PowerShell + Windows Terminal**

```powershell
# 분할 창 (Alt+Shift+-)
cd C:\projects\myapp
npm test
git add . ; git commit -m "fix: bug" ; git push
```

근데... PowerShell에서 `&&` 안 된다. `;`을 써야 한다.

**옵션 2: WSL2 + Windows Terminal**

```bash
# WSL2 탭 열기
cd /home/user/projects/myapp
npm test
git add . && git commit -m "fix: bug" && git push
```

Linux 명령어 그대로 쓴다. 편하다.

**옵션 3: Git Bash**

MinGW 기반. Bash 명령어 일부 지원. 근데 제한적이다:
- 패키지 관리자 없음
- symbolic link 제한적
- 성능이 WSL2보다 떨어짐

**선택 기준**

- Windows 도구 자동화? → PowerShell
- 크로스 플랫폼 개발? → WSL2
- 빠른 Git 작업만? → Git Bash

## 성능 비교

### 속도 테스트

**Bash**:
- 가볍다
- 텍스트 처리 빠르다
- 파일 작업 빠르다

**PowerShell**:
- 무겁다
- 객체 생성 오버헤드
- 대규모 파일 작업에서 Bash보다 느림

Reddit에서 본 댓글: "같은 작업을 PowerShell과 Bash로 돌려봤는데, Bash가 훨씬 빠르더라. CPU랑 RAM도 덜 먹고."

근데 PowerShell의 장점도 있다. Windows API 접근은 PowerShell이 압도적. WMI, 레지스트리, Active Directory... 이런 거 다룰 때는 PowerShell이 필수다.

### WSL2 I/O 성능

WSL1은 I/O가 병목이었다. Git 작업이 엄청 느렸다.

WSL2는 훨씬 낫다. 진짜 Linux 커널이라서. 근데 여전히 네이티브 Linux보다는 느리다.

팁: WSL2 파일 시스템 내부에서 작업하면 빠르다. Windows 파일 시스템(`/mnt/c/`) 접근하면 느려진다.

## 크로스 플랫폼 스크립팅

PowerShell Core (v6+)는 Linux, macOS에서도 돌아간다:

```bash
# macOS/Linux에서
brew install powershell
pwsh
```

근데... 쓸 이유가 있나?

**찬성**:
- 객체 파이프 강력하다
- JSON, CSV 처리 편하다
- Windows, Linux, macOS 동일한 스크립트

**반대**:
- Bash가 더 보편적이다
- Linux 시스템 관리는 Bash가 낫다
- WMI 같은 Windows 기능은 Linux에서 안 된다

실전에서는 혼용한다:
- Windows 관리: PowerShell
- Linux 서버 관리: Bash
- 데이터 처리: Python

## AI 코딩 시대의 CLI

Cursor, OpenCode, GitHub Copilot CLI... CLI 기반 AI 도구가 늘고 있다.

**왜 CLI인가?**

1. 컨텍스트 스위칭 없음 (IDE 왔다갔다 안 해도 됨)
2. Git 작업 통합 (자동 커밋 메시지)
3. 멀티 파일 편집 자동화
4. 터미널 네이티브 (키보드만 사용)

**CLI 코딩 에이전트들**:

- **Claude Code**: 추론 능력 최고, Anthropic 제작
- **Cursor CLI**: VS Code 통합
- **Gemini CLI**: Google AI
- **OpenCode**: 유연한 모델 선택
- **Aider**: Git 중심 워크플로우

예시:

```bash
# Claude Code
claude "refactor this function to use async/await"

# 자동으로 파일 수정, 테스트, 커밋까지
```

이게 가능한 이유? Unix 철학의 승리다. 작은 도구들을 조합하고, 텍스트로 통신하고, 파이프로 연결한다. AI가 이 패턴을 따른다.

Windows에서도 WSL2 + AI CLI 도구 조합으로 가능하다.

## 실전 팁: 어느 걸 써야 할까?

### 상황별 추천

**순수 Windows 개발 (C#, .NET, Azure)**
→ PowerShell + Windows Terminal

이유:
- Windows API 접근 필수
- Active Directory, Exchange 관리
- Azure CLI도 PowerShell과 궁합 좋음

**웹 개발 (Node.js, Python, Ruby)**
→ WSL2 + Windows Terminal

이유:
- npm, pip 속도 빠름
- Bash 스크립트 그대로 사용
- Docker 성능 좋음
- 배포 환경과 동일

**크로스 플랫폼 도구 개발**
→ PowerShell Core (조건부)

이유:
- Windows, Linux, macOS 동일 코드
- 객체 파이프 강력
- 근데 Bash가 더 보편적

**DevOps / 인프라 관리**
→ 혼용

이유:
- Windows 서버: PowerShell
- Linux 서버: Bash
- 자동화 스크립트: Python

### 맥북 개발자가 Windows로 넘어간다면?

1. **WSL2 먼저 설치**:
   ```powershell
   wsl --install -d Ubuntu-20.04
   ```

2. **Windows Terminal 설치**:
   - Microsoft Store에서 다운로드
   - WSL 프로필 기본으로 설정

3. **Scoop 설치**:
   ```powershell
   iwr -useb get.scoop.sh | iex
   scoop install git nodejs python
   ```

4. **VS Code Remote-WSL 확장**:
   - WSL 내부 파일을 VS Code에서 편집
   - 터미널도 WSL 사용

5. **oh-my-zsh 설정**:
   ```bash
   # WSL 내부에서
   sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
   ```

이러면 macOS와 거의 비슷한 환경이 된다.

### Windows 개발자가 PowerShell 마스터한다면?

1. **PowerShell 7 설치**:
   ```powershell
   winget install Microsoft.PowerShell
   ```

2. **PSReadLine 모듈**:
   - 명령어 히스토리 강화
   - 자동완성 개선

3. **Posh-Git**:
   - Git 상태 프롬프트에 표시
   - 탭 완성 지원

4. **Windows Terminal 커스터마이징**:
   - Quake mode 설정
   - 단축키 매핑
   - 테마 적용

5. **Chocolatey/Scoop**:
   - 패키지 관리자 선택
   - 스크립트로 환경 복원

## 결론

"PowerShell이 Bash보다 강력한가?"

**질문 자체가 틀렸다.**

둘은 다른 철학으로 만들어졌다. Bash는 50년 역사의 텍스트 처리 도구다. PowerShell은 .NET 기반 객체 자동화 엔진이다.

**개발자 관점에서 정리:**

**Unix/macOS CLI의 장점:**
- 가볍고 빠르다
- 텍스트 처리 최강
- 거대한 생태계 (30년 이상)
- 배포 환경과 동일 (대부분 서버가 Linux)
- 패키지 관리 간단 (Homebrew)
- Symbolic link 자유

**Windows CLI의 장점:**
- 객체 파이프 강력
- Windows API 접근 용이
- .NET Framework 통합
- Active Directory, Exchange 관리 필수
- WSL2로 양쪽 다 쓸 수 있음

**내 선택?**

맥북에서 개발한다. Terminal + zsh + oh-my-zsh. 이게 편하다. Homebrew로 뭐든 설치하고, Bash 스크립트로 자동화하고, tmux로 세션 관리한다.

근데 Windows 써야 한다면? WSL2 + Windows Terminal 조합이다. 양쪽 세계의 장점을 다 가져간다. PowerShell은... Windows 관리 작업할 때만 쓸 것 같다.

**최종 답:**

Unix 기반 터미널과 PowerShell이 "대등한가?"

아니다. **다르다**. 

Unix는 텍스트 처리와 파이프 조합의 예술이다. PowerShell은 Windows 자동화의 필수 도구다.

둘 다 배워라. 선택이 아니라 도구다. 상황에 맞는 걸 쓰면 된다.

바이브 코딩 시대에 CLI는 더 중요해진다. AI가 명령어 생성해주지만, 개발자는 그 명령어가 뭘 하는지 알아야 한다.

CLI 마스터는 여전히 개발자의 기본기다.

---

**참고: 코드 예시들**

### Bash 스크립트 예시 (백업 자동화)

```bash
#!/bin/bash
# backup.sh - 파일 백업 스크립트

BACKUP_DIR="/backup"
SOURCE_DIR="/home/user/projects"
DATE=$(date +%Y%m%d_%H%M%S)
ARCHIVE="backup_${DATE}.tar.gz"

echo "백업 시작: $SOURCE_DIR"
tar -czf "${BACKUP_DIR}/${ARCHIVE}" "$SOURCE_DIR"

if [ $? -eq 0 ]; then
    echo "백업 완료: ${BACKUP_DIR}/${ARCHIVE}"
    # 7일 이상 된 백업 파일 삭제
    find "$BACKUP_DIR" -name "backup_*.tar.gz" -mtime +7 -delete
else
    echo "백업 실패!" >&2
    exit 1
fi
```

### PowerShell 스크립트 예시 (시스템 모니터링)

```powershell
# monitor.ps1 - 시스템 리소스 모니터링

$cpuThreshold = 80
$memoryThreshold = 90

# CPU 사용률 체크
$cpu = Get-Counter '\Processor(_Total)\% Processor Time' | 
    Select-Object -ExpandProperty CounterSamples | 
    Select-Object -ExpandProperty CookedValue

if ($cpu -gt $cpuThreshold) {
    Write-Warning "CPU 사용률 높음: $($cpu.ToString('F2'))%"
    
    # 상위 5개 프로세스 출력
    Get-Process | Sort-Object CPU -Descending | 
        Select-Object -First 5 Name, CPU, WorkingSet
}

# 메모리 사용률 체크
$os = Get-CimInstance Win32_OperatingSystem
$memoryUsed = ($os.TotalVisibleMemorySize - $os.FreePhysicalMemory) / 
              $os.TotalVisibleMemorySize * 100

if ($memoryUsed -gt $memoryThreshold) {
    Write-Warning "메모리 사용률 높음: $($memoryUsed.ToString('F2'))%"
}
```

### tmux 설정 예시 (.tmux.conf)

```bash
# 프리픽스 키 변경 (Ctrl+b → Ctrl+a)
unbind C-b
set -g prefix C-a
bind C-a send-prefix

# 분할 창 단축키
bind | split-window -h
bind - split-window -v

# 마우스 지원
set -g mouse on

# 상태바 설정
set -g status-bg colour235
set -g status-fg colour136
```

이게 개발자가 바라보는 Windows CLI vs Unix CLI의 현실이다.

#Windows #Unix #CLI #PowerShell #Terminal #WSL2 #DevTools
