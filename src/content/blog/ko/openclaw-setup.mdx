---
title: "OpenClaw는 설치보다 운영이 어렵다: 텔레그램 “명령 수신”까지 열어야 자동화가 굴러간다"
date: 2026-02-09
category: 'development'
author: denosinfo
tags: [OpenClaw, AI Agent, Telegram, Automation, Security, MacOS]
description: "OpenClaw 설치 후 겪게 되는 Gateway, 텔레그램 권한, 브라우저 연동 문제를 실무 관점에서 해결합니다. LaunchAgent 환경 변수 문제부터 스킬 보안 관리까지 운영 노하우를 공유합니다."
heroImage: "/images/openclaw_gateway_architecture_1770617594667.png"
---

OpenClaw 설치는 금방 끝난다.
진짜 난이도는 채널과 권한에서 올라간다.

특히 macOS에서 Gateway를 LaunchAgent로 돌리는 순간, 토큰과 권한이 분리돼 사고가 난다.
이 글은 “설치 → 텔레그램 세팅 → 명령 수신(인바운드) → 브라우저 릴레이”까지 실제로 막히는 지점을 기준으로 정리한다.

<br/>

## Gateway가 상주하는 구조를 먼저 잡는다

![사용자 터미널과 LaunchAgent 데몬 사이의 '보이지 않는 벽' 시각화](/images/openclaw_gateway_architecture_1770617594667.png)

OpenClaw는 CLI 한 번 실행으로 끝나는 도구가 아니다.
채널 연결과 에이전트 실행을 받는 Gateway가 상주하는 구조다.

그래서 설치 직후 `openclaw status`에서 connected로 보이더라도, “누가 실행 주체인가”를 먼저 확인해야 한다.
LaunchAgent로 Gateway가 실행되면 터미널 세션과 환경이 분리된다는 점이 이후 모든 문제의 출발점이다.

<br/>

## LaunchAgent 환경에서 “export가 먹히지 않는” 이유를 해결한다

터미널에서 `export TELEGRAM_BOT_TOKEN=...`를 해도, LaunchAgent가 띄운 Gateway는 그 값을 모른다.
이 분리 때문에 `openclaw status`에서 Telegram이 ON인데도 `no token`으로 뜨는 패턴이 나온다.

가장 빠른 해법은 토큰을 config에 저장하는 방식이다.
OpenClaw는 채널 설정을 `openclaw config set channels.telegram.botToken ...`로 다룰 수 있고, Gateway 재시작 후 적용된다는 동작을 문서에서도 요구한다.

<br/>

## 텔레그램 DM 정책은 pairing과 allowFrom이 핵심이다

![접속 요청을 검증하는 디지털 보안 게이트](/images/openclaw_security_pairing_v2_1770617629890.png)

텔레그램 채널의 기본 DM 정책은 `pairing`이다.
이 모드에서는 모르는 발신자가 DM을 보내면 페어링 코드만 받고, 승인 전까지 메시지를 무시한다.

승인은 `openclaw pairing list telegram`과 `openclaw pairing approve telegram <CODE>`로 처리한다.
DM을 넓게 열고 싶다면 `channels.telegram.dmPolicy="open"`을 쓰는 방식이 있는데, 이때 `channels.telegram.allowFrom`에 `"*"`가 포함돼야 한다는 검증 규칙이 붙는다.

운영 관점에서 추천은 간단하다.
개인 봇이라도 `pairing`으로 시작하고, 승인된 사용자 ID만 `allowFrom`에 넣는 방식이 안전하다.
채널이 곧 실행 권한이 되기 때문에, DM을 무턱대고 open으로 두면 사고 반경이 커진다.

<br/>

## 텔레그램으로 보내는 명령은 chatId 고정이 안정적이다

OpenClaw의 단일 출구 커맨드는 `openclaw message send`다.
텔레그램의 `--target`은 `chatId` 또는 `@username` 형태다.

현장에서 가장 단단한 방식은 pairing 로그에서 `chatId`를 한 번 확보하고, 이후 메시지 전송 타겟을 그 숫자로 고정하는 방식이다.
이렇게 고정하면 “last 같은 추상 타겟”에 의존하지 않아 재현성이 올라간다.

<br/>

## 브라우저 자동화는 Chrome Extension Relay가 기준이 된다

![브라우저 확장 프로그램과 엔진을 연결하는 디지털 브리지](/images/openclaw_browser_relay_v2_1770617644829.png)

OpenClaw는 브라우저 프로필을 여러 방식으로 운영한다.
OpenClaw-managed 브라우저를 따로 띄우는 방식도 있지만, 실전에서는 “이미 로그인된 내 Chrome 탭”을 붙이는 Extension Relay가 강하다.

이 방식은 자동으로 탭을 잡지 않는다.
사용자가 확장 아이콘으로 탭을 Attach하고, OpenClaw는 그 탭을 `targetId`로 식별해 제어한다.
설치 흐름은 `openclaw browser extension install` → `chrome://extensions`에서 Developer mode ON → Load unpacked로 확장 로드라는 형태로 문서에 정리돼 있다.

<br/>

## 추천 스킬은 “번들 allowlist”로 시작하고, 외부 스킬은 느리게 깐다

스킬은 기능 확장에 유용하지만, 공급망 리스크가 큰 영역이다.
최근 ClawHub에 악성 스킬이 대량 업로드된 정황이 보도됐고, 사용자가 로컬 실행 권한을 사실상 넘기게 된다는 점이 이슈의 핵심이다.
따라서 추천은 “무조건 많이 설치”가 아니라 “번들만 허용하고 점진 확대”다.

OpenClaw는 `skills.allowBundled`로 “번들 스킬 allowlist”를 지원한다.
문서 예시에는 번들 allowlist로 `gemini`, `peekaboo`가 등장한다.
운영 시작점은 아래 형태가 실전적이다.

- `skills.allowBundled`를 설정해 번들 스킬만 우선 노출한다.
- 외부 스킬은 `skills.load.extraDirs` 같은 로컬 디렉터리에서만 먼저 운영한다.
- 설치가 필요한 경우에도 “명령 복붙을 요구하는 스킬”은 우선 격리한다.

이 접근은 기능보다 속도가 느리다.
대신 계정 탈취나 로컬 파일 유출 같은 치명 리스크를 줄인다.
OpenClaw는 결국 로컬 실행이 강점이자 약점이라는 사실을 잊지 않아야 한다.

<br/>

## 참고자료

- OpenClaw Docs, "Telegram" (2026.02.09)
- OpenClaw Docs, "Browser (OpenClaw-managed)" (2026.02.09)
- OpenClaw Docs, "Skills" (2026.02.09)
- OpenClaw Docs, "Skills Config" (2026.02.09)
- The Verge, "OpenClaw’s AI ‘skill’ extensions are a security nightmare" (2026.02.04)
- Tom's Hardware, "Malicious OpenClaw ‘skill’ targets crypto users on ClawHub — 14 malicious skills were uploaded to ClawHub last month" (2026.02.01)
- 나의 경험
