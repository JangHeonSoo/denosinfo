---
title: 'Clawdbot > Moltbot > OpenClaw ㅋㅋㅋ'
description: '네이밍 롤러코스터를 탄 오픈소스 AI 에이전트 OpenClaw 의 개발 스토리와 활용법'
pubDate: 2026-01-31
category: 'tech'
tags: ['OpenClaw', 'AI', 'Agent', 'OSS', 'LLM', 'Automation']
heroImage: '/images/openclaw-hero.png'
---

# Clawdbot > Moltbot > OpenClaw ㅋㅋㅋ

최근 핫하다는 Clawdbot을 접했는데 갑자기 Moltbot이 되었다가 OpenClaw 로 또 이름이 바뀌었다.  
OpenClaw (구 Moltbot, 구구 Clawdbot) ㅋㅋㅋㅋㅋㅋㅋㅋ

핫한 오픈소스 프로젝트가 너무 핫해서 그런가, 며칠 사이에 이렇게 프로젝트 이름이 우왕좌왕하는 거 오랜만에 본다 ㅋㅋㅋ  
솔직히 이런 네이밍 롤러코스터, 2020년대에 보기 힘든 풍경인데 여기서 또 본다.  

그래도 이름이 세 번 바뀌는 동안, 정작 소프트웨어는 꽤 얌전히 잘 자라고 있다는 게 웃기면서도 좀 멋있다.

---

## OpenClaw가 하는 일: "챗봇"이 아니라 "내 일을 대신 해주는 놈"

처음엔 나도 그냥 "또 하나의 AI 챗봇이겠지"라고 생각했다.  
근데 구조를 뜯어보면 이건 채팅창에 붙어 있는 **에이전트 허브**에 가깝다.

핵심 느낌만 요약하면:

- 자기 서버나 VPS, 혹은 Cloudflare Workers 위에 돌릴 수 있는 **셀프 호스팅 AI 비서**다.
- WhatsApp, Telegram, 웹 대시보드, 터미널 TUI 같은 **이미 쓰고 있는 채널 위에 얹어서** 쓴다.
- 백엔드에서 어떤 모델을 붙이든 상관없다. Claude든 OpenAI든, 심지어 Ollama에서 로컬 LLM 돌려도 된다.
- "스킬(Skill)" 플러그인 구조로 메일 보내기, 캘린더 관리, GitHub PR 확인 같은 액션을 모듈처럼 꽂아 쓴다.

요걸 한 줄로 줄이면:  
> "채팅으로 이런저런 부탁을 했을 때, 실제로 내 맥/서버에서 커맨드도 치고, API도 때리고, 메일도 보내고, 캘린더도 만지는 오토파일럿 친구"

---

## 개발자의 눈으로 본 구조 (대충 머릿속 UML)

문서 그림 대신 뇌피셜 UML로 적으면 느낌이 딱 이렇다:

- **Gateway**: 항상 켜져 있는 중추 서버.  
  - 채널(텔레그램, 웹, 터미널…)이랑 LLM, 각종 스킬을 다 여기 붙인다.
- **Channels**: WhatsApp / Telegram / Web / TUI / Workers 등등.  
  - 유저가 실제로 말 거는 입구.
- **Skills**: GitHub, 이메일, 캘린더, 파일 액세스 같은 실제 액션 레이어.
- **LLM Provider**: Anthropic, OpenAI, Gemini, 로컬 모델 등.

LLM은 그냥 "뇌"이고, 스킬은 "손발" 느낌이다.  
게이트웨이가 둘을 연결해서 "야, 이번 대화에선 캘린더 스킬 써서 일정 등록해" 이런 식으로 호출을 orchestrate 한다.

---

## 설치 & 세팅 삽질기: "이게 왜 안되지?" → "아, 이거였구나"

### 1) 기본 설치 루트 (Node + Docker + 온보딩)

대부분의 가이드는 이렇게 시작한다:

1. Node.js 22+ 설치 (로컬이든 VPS든).
2. OpenClaw(혹은 Moltbot, Clawdbot 시절) 게이트웨이 설치.
3. 온보딩 커맨드 한 방.

예를 들어 Moltbot 시절 가이드에는 이런 식으로 나와 있다:

```bash
# 온보딩 + 데몬 설치까지 한 번에
curl -fsSL https://openclaw.ai/install.sh | bash
```

이게 뭘 하냐면: LLM 제공자 설정, 워크스페이스 생성, 채널 연결, systemd 서비스 등록까지 쭉 밀어준다.  
사실 "한 방에 끝"이라는 말은 늘 위험한데, 여기서도 예외는 아니었다.

### 2) 첫 번째 삽질: LLM 키 안 넣고 "왜 말이 없지?"

온보딩 돌리다 보면 "Claude/OpenAI/Gemini 중에서 뭘 쓸래?" 이런 구간이 나온다.  
일단 귀찮아서 "나중에 넣지 뭐" 하고 키를 생략해버렸다.

결과: 텔레그램에서 봇이 말을 안 한다.  
정확히 말하면 봇은 메시지를 받는데, 뒤에서 LLM 호출이 전부 실패해서 응답이 0. 로그에는 당연히 API Key 관련 에러가 떠 있다.

"이게 왜 안되지?" 하면서 한참 삽질하다가  
→ "아, 이거였구나" 하고 `ANTHROPIC_API_KEY`, `OPENAI_API_KEY` 같은 환경변수 다시 채운 뒤 재시작.

### 3) 두 번째 삽질: Gateway Token 안 메모해두고 멍때림

호스팅 가이드에 보면 `OPENCLAW_GATEWAY_TOKEN`을 꼭 복사해서 어딘가에 잘 보관하라고 한다.  
당연히 나는 "나중에 다시 볼 수 있겠지" 하고 넘겼다.

웹 인터페이스 들어가니까 "Gateway Token 넣어라"고 친절하게 요구.  
대충 느낌이 온다. "아… 그때 그 토큰이었구나."

결국 Docker 로그 다시 뒤져서 토큰을 찾아냈다.  
이런 건 그냥 `.env`나 시크릿 매니저에 바로 넣어두는 습관을 만드는 게 정신 건강에 좋다.

---

## OpenClaw의 강점 (개발자 입장에서 꽤 매력적인 포인트)

### 1) "내 서버에 돌리는 AI 비서"라는 컨셉

- SaaS형 AI 에이전트 서비스랑 달리, 자기 서버 / VPS / Workers 위에 직접 올릴 수 있다.
- LLM 키도 내가 관리하고, 파일 액세스 범위도 내가 제어한다. SSH 권한까지 주면 진짜 무서운 짓도 시킬 수 있다.
- 개인정보, 코드 레포, 내부 위키 같은 걸 붙여도 "그래도 내 인프라 안에서 돈다"는 안심이 있다.

### 2) 스킬 기반 확장성

스킬 모음 레포를 보면 별별 게 다 있다. GitHub, 홈브류, iCloud Find My, HealthKit, 미디어 백업 등등.  
설치 방법도 생각보다 단순하다:

```bash
# ClawdHub CLI로 스킬 설치
npx clawdhub@latest install github-pr
```

혹은 아예 폴더 복사:

- 글로벌: `~/.openclaw/skills/`
- 워크스페이스: `<project>/skills/`

워크스페이스 > 로컬 > 번들 우선순위라, 프로젝트별로 다른 스킬 구성을 둘 수 있다.  
개발자 입장에선 "한 번 프레임만 익혀두면, 나만의 스킬을 꽂아 넣는 재미"가 있다.

### 3) "이미 쓰고 있는 채팅 앱"에 얹는 UX

WhatsApp, Telegram 같은 메신저에 붙여 쓰는 구조라, 새로운 UI를 배우지 않아도 된다.  
터미널 TUI도 있어서 그냥 `ssh` 들어가서 챗봇이랑 얘기하는 느낌으로 쓸 수 있다.

"새로운 SaaS에 로그인해서, 또 하나의 인박스를 관리하는" 피로감이 없다는 게 꽤 큰 장점이다.

---

## 약점 / 불안한 포인트 (그래도 까볼 건 까보자)

### 1) 보안/권한 설계 센스 없으면 바로 "사고"

이놈의 강점이자 약점이다.  
OpenClaw는 실제 시스템 권한을 가진 스킬을 돌릴 수 있다. 이메일도 보내고, 캘린더도 만들고, Git도 건드리고, 심지어 파일도 지울 수 있다.

- LLM이 hallucination으로 이상한 커맨드를 실행하면?
- 스킬 구현 중에 권한 체크를 대충해두면?
- 채팅 채널이 털려서 공격자가 봇에게 명령 보내면?

그냥 회사 서버 한 번에 털릴 수 있다.  
실제로도 Clawdbot 시절에는 레포가 크립토 스캠 쪽에 악용되기도 했고, 각종 보안 이슈 얘기가 꾸준히 돌았다.

### 2) 네이밍/브랜딩 혼선

지금만 해도 "Clawdbot", "Moltbot", "OpenClaw" 문서가 뒤섞여 있다.  
스킬 레포도 아직 `awesome-clawdbot-skills`로 되어 있고, 설명에 "formerly known as Moltbot, originally Clawdbot"라는 문구가 달려 있다.

검색할 때 한 번에 안 나오고, 예전 가이드 / 새 가이드가 섞여 있어서 처음 접하는 사람은 좀 헷갈릴 수밖에 없다.

### 3) 리소스/컨텍스트 한계 문제

이건 모든 에이전트가 공유하는 문제인데, OpenClaw도 예외는 아니다.  
토큰 사용량이 모델 컨텍스트 85% 근처에 가면 봇이 아예 멈추거나 반응이 이상해진다는 이슈도 보고돼 있다.

긴 작업, 대화 많은 세션에서 메모리 관리 / 요약 플로우를 제대로 설계해줘야 진짜 "실무용"으로 버틸 수 있다.

---

## 텔레그램 → 노션 일정 등록 → 메일 공유: 플로우 설계

이제 실전 시나리오를 하나 만들어보자.  
"텔레그램 메시지를 수신 받으면, 노션에 일정 등록하고, 그 일정 정보를 메일로 동료/친구들에게 뿌리는" 플로우다.  
OpenClaw를 쓴다고 가정하지만, 구조 자체는 일반적인 봇 + API 통합 패턴이라 다른 플랫폼에서도 쓸 수 있다.

---

## 전체 그림 먼저

1. 텔레그램에서 일정 관련 메시지 수신 (봇 계정).
2. OpenClaw 채널 스킬이 메시지를 게이트웨이에 전달.
3. LLM이 메시지에서 "제목 / 날짜 / 시간 / 참석자 / 위치" 같은 구조화된 정보를 추출.
4. 노션 API로 캘린더 데이터베이스에 새 페이지(일정) 생성.
5. 생성된 일정 정보를 요약해서, 지정된 메일 목록으로 발송 (이메일 스킬).

실제 구현은 "채널 스킬" + "도메인 스킬" 조합으로 나눈다고 생각하면 편하다.

---

## 1단계: 텔레그램 메시지 받기

텔레그램 봇은 BotFather로 만들고, 토큰 하나 딱 나온다.  
OpenClaw 쪽에서는 "텔레그램 채널 스킬"이 이 토큰을 써서 `getUpdates`/웹훅을 처리한다.

예시 느낌의 Node 코드 (OpenClaw 안에서 도는 스킬이라고 가정):

```typescript
// skills/telegram-notion-mail/index.ts
import express from "express";
import { handleMessage } from "./logic";

const app = express();
app.use(express.json());

app.post("/telegram/webhook", async (req, res) => {
  const update = req.body;

  try {
    // 텔레그램 업데이트에서 메시지 텍스트 꺼내기
    const message = update?.message?.text ?? "";
    const chatId = update?.message?.chat?.id;

    if (!message || !chatId) {
      return res.sendStatus(200);
    }

    // OpenClaw 게이트웨이에 "이벤트"로 전달했다고 치고
    await handleMessage({ message, chatId });

    res.sendStatus(200);
  } catch (e) {
    console.error("telegram webhook error", e);
    res.sendStatus(500);
  }
});

export default app;
```

실제로는 OpenClaw의 스킬 시스템에서 HTTP 엔드포인트를 노출해서 채널과 연결하게 된다.

---

## 2단계: LLM으로 일정 정보 추출

여기서 "아, 굳이 파싱 로직 다 짤 필요 없지" 하는 생각이 든다.  
OpenAI든 Claude든 한 번 호출해서 "이 메시지를 일정 객체로 변환해줘"라고 시키면 된다.

```typescript
// skills/telegram-notion-mail/logic.ts
import { createLLMClient } from "./llm"; // OpenClaw에서 제공하는 래퍼라고 가정
import { createNotionEvent } from "./notion";
import { sendEventEmails } from "./mailer";

type ParsedEvent = {
  title: string;
  date: string;      // ISO string
  startTime?: string;
  endTime?: string;
  attendees?: string[];
  location?: string;
  note?: string;
};

export async function handleMessage({
  message,
  chatId,
}: {
  message: string;
  chatId: number;
}) {
  const llm = createLLMClient(); // Anthropic / OpenAI 등

  const prompt = `
너는 일정 파싱 봇이다.
사용자가 보낸 한국어 또는 영어 문장에서 일정 정보를 JSON으로만 추출해ra.

필드:
- title: 문자열
- date: YYYY-MM-DD 형식
- startTime: HH:MM (선택)
- endTime: HH:MM (선택)
- attendees: 이메일이나 이름 문자열 배열 (선택)
- location: 문자열 (선택)
- note: 문자열 (선택)

다른 텍스트는 출력하지 말고 JSON만 출력해라.

메시지: "${message}"
`;

  const raw = await llm.complete({
    prompt,
    maxTokens: 256,
  });

  let parsed: ParsedEvent;
  try {
    parsed = JSON.parse(raw.trim());
  } catch (e) {
    console.error("failed to parse LLM JSON", raw);
    // 실패 시에는 그냥 무시하거나, 텔레그램으로 에러 메시지 보내기
    return;
  }

  // 노션에 일정 등록
  const created = await createNotionEvent(parsed);

  // 초대 메일 발송
  await sendEventEmails(parsed, created.shareUrl);
}
```

여기까지가 "AI 에이전트가 하는 일"의 핵심이다.  
메시지를 받아서 → LLM에게 구조화를 시키고 → 나머지는 그냥 평범한 API 호출.

---

## 3단계: 노션에 일정 등록

노션 쪽은 이미 "텔레그램 → 노션 노트 동기화" 같은 봇 사례가 꽤 있다.  
우리는 캘린더 데이터베이스를 하나 만들어두고, 여기에 페이지를 추가한다고 가정하자.

```typescript
// skills/telegram-notion-mail/notion.ts
import { Client } from "@notionhq/client";

const notion = new Client({
  auth: process.env.NOTION_API_KEY, // env에서 관리
});

const NOTION_DATABASE_ID = process.env.NOTION_EVENT_DB_ID!;

type ParsedEvent = {
  title: string;
  date: string;
  startTime?: string;
  endTime?: string;
  attendees?: string[];
  location?: string;
  note?: string;
};

export async function createNotionEvent(event: ParsedEvent) {
  const { title, date, startTime, endTime, attendees, location, note } = event;

  const fullDate = startTime
    ? `${date}T${startTime}:00`
    : `${date}T09:00:00`;

  const fullEnd = endTime
    ? `${date}T${endTime}:00`
    : undefined;

  const res = await notion.pages.create({
    parent: { database_id: NOTION_DATABASE_ID },
    properties: {
      Name: {
        title: [{ text: { content: title } }],
      },
      Date: {
        date: {
          start: fullDate,
          end: fullEnd,
        },
      },
      Location: location
        ? {
            rich_text: [{ text: { content: location } }],
          }
        : undefined,
      Attendees: attendees && attendees.length
        ? {
            multi_select: attendees.map((a) => ({ name: a })),
          }
        : undefined,
    },
    children: note
      ? [
          {
            object: "block",
            type: "paragraph",
            paragraph: {
              rich_text: [{ type: "text", text: { content: note } }],
            },
          },
        ]
      : [],
  });

  // 노션 페이지 공유 URL은 별도 로직이 필요할 수 있지만,
  // 여기선 단순하게 URL 패턴을 만든다고 가정
  const shareUrl = `https://www.notion.so/${res.id.replace(/-/g, "")}`;

  return { id: res.id, shareUrl };
}
```

여기서 한 번 삽질할 포인트:

- 데이터베이스 속성 이름(`Name`, `Date`, `Location` 등)이 실제 노션 DB 속성이랑 안 맞으면 바로 400 터진다.
- 특히 날짜 속성 타입을 "텍스트"로 만들어놓고 Date 객체를 보내면 에러 메시지가 애매해서 한참 헤맨다.

"이게 왜 안되지?" → "아, 속성 타입이 텍스트였네…" 순간.

---

## 4단계: 등록된 일정 정보를 메일로 공유

OpenClaw 쪽에는 이미 이메일 관련 스킬이 붙어 있는 구성이 많다. inbox 정리, 메일 발송 같은 것들.  
우리는 간단하게 SMTP/트랜잭션 메일 API(SendGrid, Resend 등)를 래핑한 스킬 하나를 쓴다고 치자.

```typescript
// skills/telegram-notion-mail/mailer.ts
import nodemailer from "nodemailer";

type ParsedEvent = {
  title: string;
  date: string;
  startTime?: string;
  endTime?: string;
  attendees?: string[];
  location?: string;
  note?: string;
};

const EMAIL_FROM = process.env.MAIL_FROM!;
const EMAIL_TO_LIST = (process.env.MAIL_TO_LIST ?? "")
  .split(",")
  .map((x) => x.trim())
  .filter(Boolean);

const transporter = nodemailer.createTransport({
  host: process.env.MAIL_HOST,
  port: Number(process.env.MAIL_PORT ?? 587),
  secure: false,
  auth: {
    user: process.env.MAIL_USER,
    pass: process.env.MAIL_PASS,
  },
});

export async function sendEventEmails(event: ParsedEvent, notionUrl: string) {
  if (!EMAIL_TO_LIST.length) return;

  const { title, date, startTime, endTime, location, note } = event;

  const subject = `[일정 공유] ${title} - ${date}`;
  const timeRange = startTime
    ? endTime
      ? `${startTime} ~ ${endTime}`
      : `${startTime} ~ (시간 미정)`
    : "시간 미정";

  const html = `
  <h2>새 일정이 등록되었습니다</h2>
  <ul>
    <li><b>제목</b>: ${title}</li>
    <li><b>날짜</b>: ${date}</li>
    <li><b>시간</b>: ${timeRange}</li>
    ${location ? `<li><b>장소</b>: ${location}</li>` : ""}
  </ul>
  <p>노션 링크: <a href="${notionUrl}">${notionUrl}</a></p>
  ${note ? `<p>메모: ${note}</p>` : ""}
  `;

  await transporter.sendMail({
    from: EMAIL_FROM,
    to: EMAIL_TO_LIST,
    subject,
    html,
  });
}
```

환경변수(`MAIL_HOST`, `MAIL_USER`, `MAIL_PASS`, `MAIL_TO_LIST`)만 잘 맞춰놓으면 된다.  
여기서도 역시 한 번쯤은 "포트 465/587/25 뭐가 맞더라…" 하면서 로그랑 씨름하게 된다.

---

## 5단계: 스택오버플로우 검색 타임

중간에 분명 이런 단계가 온다.

- 노션 API에서 애매한 에러 메시지 던질 때
- 텔레그램 웹훅 SSL 이슈
- nodemailer TLS 설정 꼬였을 때

그럴 때 검색창에 이런 걸 치게 된다:

- `notion api invalid_request_url database_id`
- `telegram webhook 400 bad request bot`
- `nodemailer self signed certificate in certificate chain`

스택오버플로우 대답을 대충 읽다가,  
"아, 이거였구나" 하는 순간 몇 번 지나면 플로우가 굴러가기 시작한다.  
이 부분은 사실 툴 이름과 상관없이, 개발자가 사는 방식 그 자체.

---

## 핵심 포인트 4개만 딱 정리

1. **OpenClaw는 "내 서버에 붙은 AI 비서"다**  
   - 채팅앱(텔레그램·WhatsApp·웹·TUI) 위에서 돌고, 실제 시스템/서비스에 손을 뻗는 에이전트 허브 느낌이다.

2. **스킬 구조가 확실해서, 개발자가 자기 도메인 스킬 만들기 좋다**  
   - GitHub, 캘린더, 이메일, 홈브류까지 이미 스킬 모음이 있고, 폴더 하나 추가해서 새 스킬을 꽂을 수 있다.

3. **보안/권한 설계 삐끗하면 진짜 위험해진다**  
   - LLM한테 시스템 권한을 위임하는 셈이라, 토큰 관리, 파일 접근 범위, 채널 보안 등은 직접 챙겨야 한다.

4. **텔레그램 → 노션 일정 → 메일 공유 플로우는 "채널 + LLM 파싱 + 두 개의 API 호출" 조합으로 깔끔하게 구현 가능**  
   - 메시지 수신 → LLM으로 일정 구조화 → 노션 DB 페이지 생성 → 메일 전송, 이 네 단계를 스킬로 쪼개면 재사용성도 좋다.

이 정도 감각만 잡아두면, "챗봇이 내 일을 대신 해주는" 쪽으로 슬슬 스택을 확장해 볼 수 있다.  
이름이 뭐가 됐든, 결국 중요한 건 내가 시킨 일을 제대로 대신 해주냐니까.

#OpenClaw #AI #Agent #OSS #LLM #Automation
