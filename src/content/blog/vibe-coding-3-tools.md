---
title: "내가 경험한 바이브 코딩 툴 3대장 - 커서, 오픈코드, 구글 안티그래비티"
description: "15년 만에 다시 켠 맥북에서 만난 바이브 코딩의 충격. 커서, 안티그래비티, 오픈코드를 직접 비교해 보았습니다."
pubDate: 2026-01-30
category: "AI"
tags: ["VibeCoding", "AITools", "OpenCode", "Antigravity", "Cursor"]
heroImage: "/images/post-vibe-coding.png"
---

# 내가 경험한 바이브 코딩 툴 3대장 - 커서, 오픈코드, 구글 안티그래비티

10년은 열심히 개발하고 그후 5년은 관리자로 일하고 있었는데, 무언가 몇개 정도 다시 해보고싶어 오랜만에 맥북을 켰다.
정말 진짜진짜 오랜만에 개발(?)을 해 보았다.
개발이라고... 해야하나? 바이브 코딩은 정말 충격이었다.

## 그냥 말로만 하면 코드가 뚝딱뚝딱

사실 처음엔 믿기지 않았다. "AI한테 코딩 시키면 된다"는 말을 듣고 '에이 설마' 했는데, 직접 해보니까 진짜더라. 그런데 문제가 있었다. 어떤 툴을 써야 할지 모르겠는거다.

유튜브 뒤지고 레딧 검색하다가 세 개를 골라봤다.
- **Cursor**: 유명하다길래
- **구글 안티그래비티(Antigravity)**: 구글이 만들었다니까 
- **OpenCode**: 터미널에서 돌아간다길래

결론부터 말하자면 나는 결국 **OpenCode 1등**, **구글 안티그래비티 2등**, **Cursor 3등**으로 순위를 매겼다.

## 왜 이런 순위가 나왔냐면

### 맥락을 얼마나 기억하냐가 진짜 승부처였다

내가 짜려던 건 간단한 풀스택 앱이었다. 프론트에서 뭔가 입력하면 &#126; 백엔드 거쳐서 &#126; GCE에 있는 DB에 쌓이고 &#126; 로컬에서 작업 끝나면 다시 DB &#126; 백엔드 &#126; 프론트 순으로 되돌아오는 그런 흐름.

별로 복잡해 보이지 않았다. 그런데.

**Cursor랑 구글 안티그래비티는 자꾸 까먹더라.**

"아까 이거 프론트에서 이렇게 처리한다고 했잖아?"
"어... 그런가요? 그럼 다시 설명해주시면..."

이게 한두번도 아니고 계속 반복됐다. 매번 똑같은 맥락을 다시 상기시켜줘야 하는 번거로움. 코딩보다 설명이 더 길어지는 이 아이러니.

### OpenCode는 달랐다

처음에 내가 하고싶은거 한번 쫙 설명했더니 OpenCode가 이렇게 답했다:

```
프론트 → 백엔드 → DB 저장
로컬 처리 완료 확인
DB → 백엔드 → 프론트 연결

확인 포인트:
1. API 엔드포인트 검증
2. 로컬 작업 완료 플래그 체크
3. 프론트 콜백 연결
```

그냥... 한방에 이해하고 절차를 완벽하게 수립한다음 확인 포인트까지 명확히 제시했다.

이후에 내가 추가로 뭔가 물어봐도 앞에 말한거 다 기억하고 있었다. "아까 프론트에서 처리한 로직 기반으로 이렇게 하면 됩니다" 이런 식으로.

이게 진짜 차이였다. **맥락을 잃어버리지 않는다는 것.**

## 구글 안티그래비티의 답답함

구글 안티그래비티는 특이하게 브라우저를 직접 제어한다. 실제로 크롬 창을 켜서 웹 페이지를 보고, 클릭하고, 스크린샷 찍고 그런다.

처음엔 "오 이거 신기한데?" 했다. 

근데 쓰다보니까 답답했다. 

브라우저 켜고... 페이지 로딩하고... 스크린샷 찍고... 뭔가 확인하고...

이 모든 과정을 지켜보고 있자니 '내가 직접 하는게 빠르겠다' 싶더라.

더 짜증났던건 권한 확인이었다. 모든 설정과 권한을 다 줬는데도 자꾸 계속 무언가 확인하는 절차를 거친다. 
"브라우저 접근 허용하시겠습니까?"
"콘솔 명령 실행해도 되나요?"
"페이지 데이터 읽어도 되죠?"

보안상 그럴 수 있다는건 이해한다. 근데 매번 이러면 흐름이 끊긴다.

## Cursor는 뭐가 문제였냐

Cursor는 사실 제일 유명하고 사람들이 많이 쓴다. VS Code 기반이라 익숙하기도 하고.

근데 내 경험상 **맥락 관리가 약했다.**

채팅창에서 대화하다보면 10번째쯤 되면 앞에 했던 얘기를 까먹는다. 

"그래서 아까 프론트에서 어떻게 처리하기로 했죠?"

 이걸 다시 설명해줘야 한다. Context 추가하고, Rules 파일 만들고, 이것저것 해봤는데도 여전히 헷갈려했다.

프로젝트가 커질수록 더 심해진다. 파일이 많아지면 전체 맥락을 잡지 못하고 부분만 보는 느낌.

그래서 결국엔 작은 단위로 쪼개서 물어봐야 하는데, 그럼 내가 전체 설계를 다 머리에 넣고 있어야 한다. 그게 피곤했다.

## 내가 느낀 결정적 차이

| 도구 | 맥락 기억 | 작업 속도 | 번거로움 |
|------|-----------|-----------|----------|
| OpenCode | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐ |
| 구글 안티그래비티 | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| Cursor | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |

OpenCode는 터미널에서 돌아가는데 LSP(Language Server Protocol) 통합이 되어있어서 내 프로젝트 구조, 의존성, import 같은걸 전부 이해하고 있다. 그래서 맥락을 안 잃어버리는 것 같다.

구글 안티그래비티는 브라우저 통합이 강력한데, 그게 오히려 발목을 잡았다. 확인 절차 너무 많고 답답하다.

Cursor는 빠르긴 한데 맥락을 자꾸 잃어버린다. 짧은 작업은 괜찮은데 긴 프로젝트는 힘들다.

## 실제 코드 예시

OpenCode한테 이렇게 물어봤다:

```bash
> 프론트에서 POST 요청 보내면 백엔드에서 DB 저장하고
> 로컬 작업 끝나면 GET으로 다시 불러와서 화면 업데이트
```

그랬더니 이렇게 플랜 짜줬다:

```markdown
## 구현 계획

### 1. 프론트엔드
- POST /api/data 호출
- 로컬 작업 완료 플래그 체크
- GET /api/data 폴링

### 2. 백엔드
- POST 엔드포인트: DB 저장
- GET 엔드포인트: DB 조회

### 3. 확인 사항
- DB 연결 테스트
- 로컬 플래그 타이밍
- 프론트 폴링 주기
```

그리고 실제로 파일 3개 만들어주고 각 파일에 코드 넣어줬다. 한번에.

Cursor는 같은 요청을 5번 나눠서 해야 했다. "먼저 프론트 만들어줘" &#126; "이제 백엔드" &#126; "아 그런데 아까 프론트에서 이 부분 추가해줘" 이런 식으로.

## 삽질했던 경험들

### OpenCode 초반 삽질

처음에 OpenCode 설치하고 API 키 넣는데 자꾸 에러가 났다.

```bash
Error: API key not found
```

왜지? 분명 넣었네?

알고보니 환경변수 파일 이름이 `.opencode.json`인데 나는 `.opencode`로 만들어놨다. json 확장자를 빼먹은거다.

이런 사소한 것때문에 30분 날렸다. 공식 문서를 제대로 안읽은 내 잘못이긴 한데, 에러 메시지가 "파일 찾을 수 없음" 이런식으로 나왔으면 바로 알았을텐데.

### 구글 안티그래비티 권한 지옥

구글 안티그래비티는 브라우저 권한 때문에 진짜 화났다.

첫 실행할때 크롬 익스텐션 설치하라고 해서 설치했다. 그 다음 "브라우저 접근 허용하세요" 클릭. 그 다음 "콘솔 실행 권한 주세요" 클릭.

여기까진 괜찮았다.

근데 실제로 작업 시키면 매번 또 물어본다.
"이 페이지 데이터 읽어도 되나요?"
"폼 입력해도 되죠?"

아니 아까 다 허용했잖아! 

설정에서 "모든 권한 항상 허용" 같은거 찾아봤는데 없더라. 결국 매번 클릭해야 했다.

### Cursor의 Context 미궁

Cursor는 Context 관리가 핵심이라길래 `/docs` 명령어로 프로젝트 설명 넣고, `/rules`로 코딩 규칙 넣었다.

```
/docs
프로젝트: GCE DB 연동 앱
스택: Node.js, Express, MySQL
디렉토리: src/frontend, src/backend

/rules
- 함수형 컴포넌트 사용
- async/await 필수
- 에러 처리 try-catch
```

이렇게 깔끔하게 정리했다.

근데도 5번째 대화쯤 되니까 
"백엔드가 Express였나요?" 
이러더라.

아까 docs에 써줬잖아!!!

나중에 알게된건, Context 창에서 직접 파일들을 @ 멘션으로 추가해줘야 제대로 인식한다는거였다. 그냥 `/docs`만으로는 부족했던거다.

```
@src/backend/server.js 이 파일 기반으로 API 추가해줘
```

이렇게 해야 제대로 이해했다. 불편하다.

## 각 툴은 언제 쓰면 좋을까

그래도 공평하게 말하자면, 각자 잘하는게 있다.

**OpenCode**: 처음부터 끝까지 전체 설계가 필요한 작업. 여러 파일 오가면서 복잡한 로직 구현할때. 맥락 잃어버리면 안되는 긴 프로젝트.

**구글 안티그래비티**: 웹 페이지 테스트 자동화. UI 버그 찾기. 브라우저 조작이 필요한 작업. 단, 인내심이 필요하다.

**Cursor**: 빠른 프로토타이핑. 짧고 간단한 기능 추가. VS Code 익숙한 사람. 단, 작은 단위로 쪼개서 물어봐야 한다.

## 결론: 나는 OpenCode를 선택했다

15년만에 다시 코딩(?)을 해보면서 느낀건, 이제는 정말 말로 코드를 짜는 시대가 왔다는거다.

근데 도구 선택이 중요하다. 맥락을 잃어버리면 오히려 더 비효율적이다.

내 경험상:
1. **OpenCode** - 맥락 기억이 최고. 복잡한 작업에 최적.
2. **구글 안티그래비티** - 브라우저 제어는 강력하지만 답답함.
3. **Cursor** - 빠르지만 자주 까먹음. 짧은 작업만.

뭘 선택하든, 바이브 코딩은 진짜다. 

관리자로 5년 있다가 다시 코딩 해보니까 세상이 완전히 바뀌어있더라. 이제 코딩은 "어떻게 짤까"가 아니라 "뭘 만들까"를 고민하는 시대인것 같다.

그리고 솔직히, 다시 코딩하는거 재미있다.

---

*이 글은 MacBook Air M4에서 작성되었습니다. 실제 경험 기반이며 OpenCode, 구글 안티그래비티, Cursor 모두 2026년 1월 기준 최신 버전으로 테스트했습니다.*
